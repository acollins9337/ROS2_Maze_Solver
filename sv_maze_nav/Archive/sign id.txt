import rclpy
import cv2
import math
import numpy as np
import statistics as st
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.qos import QoSProfile, QoSDurabilityPolicy, QoSReliabilityPolicy, QoSHistoryPolicy
from sensor_msgs.msg import CompressedImage, Image
from std_msgs.msg import Int32, String, Float32
from skimage.feature import hog


class SignID(Node):
    def __init__(self):
        super().__init__('sign_id')
        # Connect to the action server

        self.fov = 62.2

        image_qos_profile = QoSProfile(depth=5)
        image_qos_profile.history = QoSHistoryPolicy.KEEP_LAST
        image_qos_profile.durability = QoSDurabilityPolicy.VOLATILE 
        image_qos_profile.reliability = QoSReliabilityPolicy.BEST_EFFORT 

        self._video_subscriber = self.create_subscription(
            CompressedImage,
            '/image_raw/compressed',
            self._image_callback,
            image_qos_profile)

        self._result_publisher = self.create_publisher(
            Int32,
            "/sign_result",
            10
        )

        self._ang_publisher = self.create_publisher(
            Float32,
            "/ang_err",
            10
        )

        self.model_path = "/home/adityarao/turtlebot3_ws/src/sv_maze_nav/sv_maze_nav/sign_classifier_knn.xml"
        self.model_ready = False

        self.img = None
        self.read_busy = False
        self.latest = None

        self.timer = self.create_timer(0.1, self._loading)

    def _loading(self):
        if self.model_ready == True:
            return
        else:
            with open(self.model_path, 'rb') as file:
                # Load the model from the file
                self.model = cv2.ml.KNearest_load(self.model_path)
                self.get_logger().info("\n Model Loaded Successfully!")
                self.model_ready = True

    def _image_callback(self, img:CompressedImage):
        if self.model_ready == False:
            msg = Int32()
            ang_msg = Float32()
            msg.data = -1
            ang_msg.data = 0.0
            self._result_publisher.publish(msg)
            self._ang_publisher.publish(ang_msg)
            return
        else:
            np_arr = np.frombuffer(img.data, np.uint8)
            image = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)

            prediction_list = []
            self.read_busy = True
            for i in range(5):
                p, ang_err = self._make_prediction(image)
                prediction_list.append(int(p))
                if i == 4:
                    self.read_busy = False

            predict_msg = Int32()
            ang_msg = Float32()
            prediction = st.mode(prediction_list)
            predict_msg.data = prediction
            ang_msg.data = ang_err
            self.latest = prediction

            self._ang_publisher.publish(ang_msg)

            self._result_publisher.publish(predict_msg)

    def _make_prediction(self, img):
        img_height = 64
        img_width = 64

        image = cv2.resize(img,(img_width,img_height))

        # Initial Image processing
        kblur=1
        blur=cv2.GaussianBlur(image,(kblur,kblur),0)
        gray=cv2.cvtColor(blur,cv2.COLOR_BGR2GRAY)
        hsv=cv2.cvtColor(blur,cv2.COLOR_BGR2HSV)

        # Implement some variables for colors to make masking easier
        #   Red Mask
        lower_red1 = np.array([0, 85, 75])
        upper_red1 = np.array([5, 255, 255])
        lower_red2 = np.array([170, 90, 80])
        upper_red2 = np.array([180, 255, 255])
        #   Green Mask
        lower_green = np.array([30, 15, 60])
        upper_green = np.array([100, 255, 255])
        #   Blue Mask
        lower_blue = np.array([101, 50, 50])
        upper_blue = np.array([130, 255, 255])

        # Create masks
        mask_red1 = cv2.inRange(hsv, lower_red1, upper_red1)
        mask_red2 = cv2.inRange(hsv, lower_red2, upper_red2)
        mask_green = cv2.inRange(hsv, lower_green, upper_green)
        mask_blue  = cv2.inRange(hsv, lower_blue, upper_blue)

        # Apply masks and image processing techniques
        full_mask = cv2.bitwise_or(cv2.bitwise_or(mask_red1,mask_red2),cv2.bitwise_or(mask_green,mask_blue))
        colored_objects = cv2.bitwise_and(gray,gray,mask=full_mask)
        ret,thresh=cv2.threshold(colored_objects,55,255,cv2.THRESH_BINARY)
        contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        m=5 # Margin in pixels so crop does not go directly to edges of object
        if len(contours) > 0:
            min_area=0.03*img_height*img_width
            large_contours = [
                c for c in contours 
                if cv2.contourArea(c) > min_area 
            ]
            if len(large_contours) == 1:
                largest_contour=max(large_contours,key=cv2.contourArea)
                x, y , w, h = cv2.boundingRect(largest_contour)
                
                cx = float(x + w/2.0)
                cy = float(y + h/2.0)

                err = cx - (img_width/2)
                ang_err = err*self.fov/img_width

                ang_err = math.radians(ang_err)
                if ang_err < 0.0:
                    ang_err += 2*math.pi

                if x-m <=0 or y-m <=0:
                    cropped = cv2.resize(gray[y:y+h, x:x+w], (img_width,img_height))
                else:
                    cropped = cv2.resize(gray[y-m:y+h+m, x-m:x+w+m], (img_width,img_height))
            else:
                cropped = thresh
                ang_err = 0.0
        else:
            cropped = thresh
            ang_err = 0.0

        # Apply HOG Methods
        gray_float=cropped.astype(np.float32)
        features, hog_image = hog(
            gray_float,
            orientations=12,
            pixels_per_cell=(10, 10),
            cells_per_block=(4, 4),
            block_norm="L2-Hys", # Improved a little bit
            visualize=True
        )
        # show_img(hog_image,"HOG")
        processed=features.flatten().reshape(1,-1).astype(np.float32)
        # self.get_logger().info(f"FEATURE SHAPE: {processed.shape}")
        ret, results, neighbours, dist = self.model.findNearest(processed, k=5)

        prediction = int(ret)

        return prediction, ang_err
    
def main():
    rclpy.init()
    rclpy.spin(SignID())
    rclpy.shutdown()

if __name__ == '__main__':
    main()