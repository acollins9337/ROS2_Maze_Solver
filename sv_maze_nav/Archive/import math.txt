import math
from rclpy.node import Node
import rclpy
from rclpy.time import Time
from rclpy.duration import Duration
from rclpy.action import ActionClient
from nav2_msgs.action import NavigateToPose
from std_msgs.msg import Bool
from geometry_msgs.msg import PoseStamped, Quaternion, PointStamped, Pose2D
import tf2_ros


def quat_to_yaw(q):
    return math.atan2(2.0 * (q.w * q.z),
                      1.0 - 2.0 * (q.z * q.z))


class MoveRobotClient(Node):
#class MoveRobotClient:
    def __init__(self):
        super().__init__('navigator')
        self.get_logger().info('NavStack Started')
 
        self._action_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')
        self.nav_busy = False

        # TF buffer/listener shared for all goals
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)

        self._wp_sub = self.create_subscription(
            Pose2D,
            '/maze_wp',
            self._waypoint_callback,
            10
        )

        self._done_pub = self.create_publisher(
            Bool,
            '/wp_done',
            10
        )

    def _waypoint_callback(self, p: Pose2D):
        if self.nav_busy:
            return
        self.send_goal(p)

    def send_goal(self, lw:Pose2D):
        
        # --- 1. Get current robot pose in map frame ---
        if not self.tf_buffer.can_transform(
            'map',
            'base_footprint',
            Time(),
            timeout=Duration(seconds=1.0)
        ):
            self.get_logger().warn('No transform map->base_footprint yet, skipping this goal')
            return
        
        try:
            # Time() with no args â†’ use latest available transform
            tf = self.tf_buffer.lookup_transform(
                'map',        # target
                'base_footprint',  # source
                Time()
            )
        except Exception as e:
            self.get_logger().error(f"TF lookup map->base_link failed: {e}")
            return None

        tx = tf.transform.translation.x
        ty = tf.transform.translation.y
        q = tf.transform.rotation
        yaw_robot = quat_to_yaw(q)

        x_rel = lw.x
        y_rel = lw.y
        yaw_rel = lw.theta

        # --- 2. Rotate the relative step into map frame and add to robot pose ---
        dx_map = x_rel * math.cos(yaw_robot) - y_rel * math.sin(yaw_robot)
        dy_map = x_rel * math.sin(yaw_robot) + y_rel * math.cos(yaw_robot)
        yaw_goal = yaw_robot + yaw_rel

        x_goal = tx + dx_map
        y_goal = ty + dy_map
        #self.get_logger().info(tx, ty)

        # --- 3. Build NavigateToPose goal in map frame (like GoalSetter) ---
        goal_msg = NavigateToPose.Goal()
        pose = PoseStamped()
        pose.header.frame_id = 'map'
        pose.header.stamp = self.get_clock().now().to_msg()
        pose.pose.position.x = float(x_goal)
        pose.pose.position.y = float(y_goal)

        q_goal = Quaternion()
        q_goal.z = math.sin(yaw_goal / 2.0)
        q_goal.w = math.cos(yaw_goal / 2.0)
        pose.pose.orientation = q_goal

        goal_msg.pose = pose

        # --- 4. Send to Nav2 ---
        if not self._action_client.wait_for_server(timeout_sec=2.0):
            self.get_logger().error("navigate_to_pose action server not available")
            return

        self.get_logger().info(
            f"Sending Nav2 goal (map frame): x={x_goal:.2f}, y={y_goal:.2f}, yaw={yaw_goal:.2f}"
        )

        self.nav_busy = True
        send_future = self._action_client.send_goal_async(goal_msg)
        send_future.add_done_callback(self._goal_response_callback)

    def _goal_response_callback(self, future: rclpy.task.Future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().warn("Nav2 goal rejected")
            self.nav_busy = False
            return

        self.get_logger().info("Nav2 goal accepted")
        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self._result_response_callback)

    def _result_response_callback(self, future: rclpy.task.Future):
        _ = future.result().result
        self.get_logger().info("Nav2 goal reached")
        self.nav_busy = False

        msg = bool()
        msg.data = True
        self._done_pub.publish(msg)

def main():
    rclpy.init()
    rclpy.spin(MoveRobotClient())
    rclpy.shutdown()

if __name__ == '__main__':
    main()
